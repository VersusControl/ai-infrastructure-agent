package agent

import (
	"context"
	"encoding/json"
	"fmt"
	"strings"
	"time"

	"github.com/tmc/langchaingo/llms"
	"github.com/versus-control/ai-infrastructure-agent/pkg/types"
)

// ========== Plan-Level Recovery Engine Implementation ==========

// DefaultPlanRecoveryEngine implements the PlanRecoveryEngine interface
type DefaultPlanRecoveryEngine struct {
	agent *StateAwareAgent
}

// NewPlanRecoveryEngine creates a new plan-level recovery engine
func NewPlanRecoveryEngine(agent *StateAwareAgent) PlanRecoveryEngine {
	return &DefaultPlanRecoveryEngine{
		agent: agent,
	}
}

// AnalyzePlanFailure analyzes a plan execution failure and generates recovery strategies
func (e *DefaultPlanRecoveryEngine) AnalyzePlanFailure(
	ctx context.Context,
	failureContext *PlanFailureContext,
) (*AIPlanRecoveryAnalysis, error) {
	startTime := time.Now()

	// Build comprehensive AI prompt for plan-level recovery
	prompt := e.GenerateRecoveryPrompt(failureContext)

	// Call AI model for analysis
	messages := []llms.MessageContent{
		{
			Role: llms.ChatMessageTypeSystem,
			Parts: []llms.ContentPart{
				llms.TextContent{Text: "You are an expert infrastructure recovery architect. When execution plans fail, you analyze the complete context and generate multiple recovery strategies that preserve completed work while fixing the failure. You provide 2-3 concrete recovery options with success probabilities, risk assessments, and complete new execution plans."},
			},
		},
		{
			Role: llms.ChatMessageTypeHuman,
			Parts: []llms.ContentPart{
				llms.TextContent{Text: prompt},
			},
		},
	}

	resp, err := e.agent.llm.GenerateContent(ctx, messages,
		llms.WithTemperature(0.1), // Low temperature for consistent, reliable analysis
		llms.WithMaxTokens(e.agent.config.MaxTokens))
	if err != nil {
		return nil, fmt.Errorf("AI consultation failed: %w", err)
	}

	// Extract response content
	var content string
	if len(resp.Choices) > 0 && len(resp.Choices[0].Content) > 0 {
		content = resp.Choices[0].Content
	} else {
		return nil, fmt.Errorf("empty response from AI model")
	}

	// Parse the AI response into structured analysis
	analysis, err := e.parsePlanRecoveryAnalysis(content)
	if err != nil {
		e.agent.Logger.WithError(err).Warn("Failed to parse AI plan recovery analysis, using fallback")
		return e.createFallbackAnalysis(failureContext), nil
	}

	// Add metadata
	analysis.AnalysisTimestamp = startTime
	analysis.AnalysisDuration = time.Since(startTime)

	// Validate strategy
	if analysis.Strategy != nil {
		if err := e.ValidateRecoveryStrategy(ctx, analysis.Strategy, failureContext); err != nil {
			e.agent.Logger.WithError(err).Warn("Strategy validation failed, creating fallback")
			return e.createFallbackAnalysis(failureContext), nil
		}
	} else {
		e.agent.Logger.Warn("No strategy generated by AI, creating fallback")
		return e.createFallbackAnalysis(failureContext), nil
	}

	e.agent.Logger.WithFields(map[string]interface{}{
		"total_steps":          analysis.Strategy.TotalSteps,
		"preserved_count":      analysis.Strategy.PreservedCount,
		"new_steps_count":      analysis.Strategy.NewStepsCount,
		"success_probability":  analysis.Strategy.SuccessProbability,
		"risk_level":           analysis.Strategy.RiskLevel,
		"confidence":           analysis.Confidence,
		"analysis_duration_ms": analysis.AnalysisDuration.Milliseconds(),
	}).Info("Plan failure analysis completed successfully")

	return analysis, nil
}

// GenerateRecoveryPrompt creates the comprehensive prompt for AI consultation
func (e *DefaultPlanRecoveryEngine) GenerateRecoveryPrompt(failureContext *PlanFailureContext) string {
	// Build placeholders map
	placeholders := make(map[string]string)

	// Execution Overview
	placeholders["executionId"] = failureContext.ExecutionID
	placeholders["executionStarted"] = failureContext.ExecutionStarted.Format(time.RFC3339)
	placeholders["originalUserIntent"] = failureContext.OriginalUserIntent
	placeholders["originalAction"] = failureContext.OriginalAction
	placeholders["totalStepsInOriginalPlan"] = fmt.Sprintf("%d", len(failureContext.OriginalPlan))
	placeholders["attemptNumber"] = fmt.Sprintf("%d", failureContext.AttemptNumber)

	// Failure Information
	placeholders["failedStepNumber"] = fmt.Sprintf("%d", failureContext.FailedStepIndex+1)
	placeholders["totalSteps"] = fmt.Sprintf("%d", len(failureContext.OriginalPlan))
	placeholders["failedStepId"] = failureContext.FailedStepID
	placeholders["failedStepName"] = failureContext.FailedStep.Name
	placeholders["failedStepDescription"] = failureContext.FailedStep.Description
	placeholders["failedStepAction"] = failureContext.FailedStep.Action
	placeholders["failedStepMcpTool"] = failureContext.FailedStep.MCPTool
	placeholders["failureError"] = failureContext.FailureError
	placeholders["failureTime"] = failureContext.FailureTime.Format(time.RFC3339)

	// Failed Step Parameters
	var failedParamsBuilder strings.Builder
	if len(failureContext.FailedStep.ToolParameters) > 0 {
		failedParamsBuilder.WriteString("\n**Failed Step Parameters**:\n")
		for key, value := range failureContext.FailedStep.ToolParameters {
			failedParamsBuilder.WriteString(fmt.Sprintf("- `%s`: %v\n", key, value))
		}
	}
	placeholders["failedStepParameters"] = failedParamsBuilder.String()

	// Completed Steps
	placeholders["completedStepsCount"] = fmt.Sprintf("%d", len(failureContext.CompletedSteps))

	var completedStepsBuilder strings.Builder
	if len(failureContext.CompletedSteps) > 0 {
		for _, completedStep := range failureContext.CompletedSteps {
			completedStepsBuilder.WriteString(fmt.Sprintf("\n### Step %d: %s\n", completedStep.StepIndex+1, completedStep.StepName))
			completedStepsBuilder.WriteString(fmt.Sprintf("- **Step ID**: %s\n", completedStep.StepID))
			if completedStep.ResourceID != "" {
				completedStepsBuilder.WriteString(fmt.Sprintf("- **Resource Created**: %s (%s)\n", completedStep.ResourceID, completedStep.ResourceType))
			}
			completedStepsBuilder.WriteString(fmt.Sprintf("- **Status**: %s ✅\n", completedStep.Status))
			completedStepsBuilder.WriteString(fmt.Sprintf("- **Completed At**: %s\n", completedStep.CompletedAt.Format(time.RFC3339)))

			if len(completedStep.Output) > 0 {
				completedStepsBuilder.WriteString("- **Output Data**:\n")
				for key, value := range completedStep.Output {
					completedStepsBuilder.WriteString(fmt.Sprintf("  - `%s`: %v\n", key, value))
				}
			}
		}
	} else {
		completedStepsBuilder.WriteString("\nNo steps completed yet - failure occurred on first step.\n")
	}
	placeholders["completedStepsDetails"] = completedStepsBuilder.String()

	// Remaining Steps
	placeholders["remainingStepsCount"] = fmt.Sprintf("%d", len(failureContext.RemainingSteps))

	var remainingStepsBuilder strings.Builder
	if len(failureContext.RemainingSteps) > 0 {
		for i, remainingStep := range failureContext.RemainingSteps {
			remainingStepsBuilder.WriteString(fmt.Sprintf("\n### Remaining Step %d: %s\n", i+1, remainingStep.Name))
			remainingStepsBuilder.WriteString(fmt.Sprintf("- **Step ID**: %s\n", remainingStep.ID))
			remainingStepsBuilder.WriteString(fmt.Sprintf("- **Action**: %s\n", remainingStep.Action))
			remainingStepsBuilder.WriteString(fmt.Sprintf("- **MCP Tool**: %s\n", remainingStep.MCPTool))
			if len(remainingStep.DependsOn) > 0 {
				remainingStepsBuilder.WriteString(fmt.Sprintf("- **Depends On**: %v\n", remainingStep.DependsOn))
			}
		}
	}
	placeholders["remainingStepsDetails"] = remainingStepsBuilder.String()

	// Current Infrastructure State
	var stateBuilder strings.Builder
	if failureContext.CurrentState != nil && len(failureContext.CurrentState.Resources) > 0 {
		stateBuilder.WriteString("\n## Current Infrastructure State\n\n")
		stateBuilder.WriteString(fmt.Sprintf("**%d resources currently exist in infrastructure:**\n\n", len(failureContext.CurrentState.Resources)))
		for resourceID, resource := range failureContext.CurrentState.Resources {
			stateBuilder.WriteString(fmt.Sprintf("- **%s** (%s): %s\n", resourceID, resource.Type, resource.Status))
		}
	}
	placeholders["currentInfrastructureState"] = stateBuilder.String()

	// Resource Mappings
	var mappingsBuilder strings.Builder
	if len(failureContext.ResourceMappings) > 0 {
		mappingsBuilder.WriteString("\n## Resource Mappings (Step → Resource)\n\n")
		for stepID, resourceID := range failureContext.ResourceMappings {
			mappingsBuilder.WriteString(fmt.Sprintf("- Step `%s` → Resource `%s`\n", stepID, resourceID))
		}
	}
	placeholders["resourceMappings"] = mappingsBuilder.String()

	// Previous Recovery Attempts
	var attemptsBuilder strings.Builder
	if len(failureContext.PreviousRecoveryAttempts) > 0 {
		attemptsBuilder.WriteString("\n## Previous Recovery Attempts\n\n")
		attemptsBuilder.WriteString(fmt.Sprintf("**This is recovery attempt #%d. Previous attempts:**\n\n", failureContext.AttemptNumber))
		for _, attempt := range failureContext.PreviousRecoveryAttempts {
			attemptsBuilder.WriteString(fmt.Sprintf("### Attempt %d\n", attempt.AttemptNumber))
			attemptsBuilder.WriteString(fmt.Sprintf("- **Strategy Used**: %s\n", attempt.SelectedStrategy))
			attemptsBuilder.WriteString(fmt.Sprintf("- **Failed Because**: %s\n", attempt.FailureReason))
			if attempt.FailedAtStepID != "" {
				attemptsBuilder.WriteString(fmt.Sprintf("- **Failed At Step**: %s\n", attempt.FailedAtStepID))
			}
			attemptsBuilder.WriteString(fmt.Sprintf("- **Duration**: %s\n\n", attempt.Duration))
		}
	}
	placeholders["previousRecoveryAttempts"] = attemptsBuilder.String()

	// Available Tools - Use existing generateMCPToolsSchema for consistency
	// Get tool count from agent's MCP tools
	e.agent.capabilityMutex.RLock()
	toolsCount := len(e.agent.mcpTools)
	e.agent.capabilityMutex.RUnlock()

	placeholders["availableToolsCount"] = fmt.Sprintf("%d", toolsCount)

	// Generate MCP tools schema using the same method as other prompts
	toolsSchema := e.agent.generateMCPToolsSchema()
	placeholders["availableToolsDetails"] = toolsSchema

	// Load and process template
	prompt, err := e.agent.loadTemplateWithPlaceholders("settings/templates/recovery-prompt-optimized.txt", placeholders)
	if err != nil {
		e.agent.Logger.WithError(err).Error("Failed to load recovery prompt template, using fallback")
		// Return minimal fallback prompt
		return fmt.Sprintf(`Analyze this plan failure and generate a recovery strategy in JSON format:

Execution: %s
Failed Step: %s (step %d/%d)
Error: %s

Completed Steps (%d):
%s

Generate ONE recovery strategy with standard ExecutionPlanStep format. Return only valid JSON.`,
			failureContext.ExecutionID,
			failureContext.FailedStepID,
			failureContext.FailedStepIndex+1,
			len(failureContext.OriginalPlan),
			failureContext.FailureError,
			len(failureContext.CompletedSteps),
			func() string {
				var b strings.Builder
				for _, s := range failureContext.CompletedSteps {
					b.WriteString(fmt.Sprintf("- %s: %s\n", s.StepID, s.ResourceID))
				}
				return b.String()
			}())
	}

	return prompt
}

// ValidateRecoveryStrategy ensures the proposed recovery strategy is safe and feasible
func (e *DefaultPlanRecoveryEngine) ValidateRecoveryStrategy(
	ctx context.Context,
	strategy *PlanRecoveryStrategy,
	failureContext *PlanFailureContext,
) error {

	// Validate action (same as AgentDecision)
	validActions := map[string]bool{
		"create_infrastructure": true,
		"update_infrastructure": true,
		"delete_infrastructure": true,
	}
	if !validActions[strategy.Action] {
		return fmt.Errorf("invalid action: %s", strategy.Action)
	}

	// Validate confidence
	if strategy.Confidence < 0.0 || strategy.Confidence > 1.0 {
		return fmt.Errorf("invalid confidence: %f (must be 0.0-1.0)", strategy.Confidence)
	}

	// Validate success probability
	if strategy.SuccessProbability < 0.0 || strategy.SuccessProbability > 1.0 {
		return fmt.Errorf("invalid success probability: %f (must be 0.0-1.0)", strategy.SuccessProbability)
	}

	// Validate risk level
	validRiskLevels := map[string]bool{"low": true, "medium": true, "high": true}
	if !validRiskLevels[strategy.RiskLevel] {
		return fmt.Errorf("invalid risk level: %s (must be low/medium/high)", strategy.RiskLevel)
	}

	// Validate execution plan
	if len(strategy.ExecutionPlan) == 0 {
		return fmt.Errorf("execution plan must have at least one step")
	}

	// Validate step counts match the actual execution plan length
	// TotalSteps should equal the length of executionPlan (completed + new + remaining)
	if strategy.TotalSteps != len(strategy.ExecutionPlan) {
		return fmt.Errorf("total steps (%d) doesn't match execution plan length (%d)",
			strategy.TotalSteps, len(strategy.ExecutionPlan))
	}

	// Validate that preserved count doesn't exceed total
	if strategy.PreservedCount > strategy.TotalSteps {
		return fmt.Errorf("preserved count (%d) cannot exceed total steps (%d)",
			strategy.PreservedCount, strategy.TotalSteps)
	}

	// Validate tools exist
	e.agent.capabilityMutex.RLock()
	defer e.agent.capabilityMutex.RUnlock()

	for _, step := range strategy.ExecutionPlan {
		// Validate step action
		if step.Action != "create" && step.Action != "query" {
			return fmt.Errorf("invalid step action: %s (must be create or query)", step.Action)
		}

		if step.MCPTool == "" {
			return fmt.Errorf("step %s missing mcpTool", step.ID)
		}
		// Check tool exists
		if _, exists := e.agent.mcpTools[step.MCPTool]; !exists {
			return fmt.Errorf("tool %s not available", step.MCPTool)
		}
	}

	return nil
}

// ========== Private Helper Methods ==========

// parsePlanRecoveryAnalysis parses the AI response into structured analysis
func (e *DefaultPlanRecoveryEngine) parsePlanRecoveryAnalysis(response string) (*AIPlanRecoveryAnalysis, error) {
	// Use existing agent JSON processing methods
	var jsonStr string

	// Try primary extraction method
	jsonStr = e.agent.extractJSON(response)

	// If primary method fails, try alternative methods
	if jsonStr == "" {
		jsonStr = e.agent.extractJSONAlternative(response)
	}

	// If still no JSON found, try truncated JSON parsing
	if jsonStr == "" {
		jsonStr = e.agent.attemptTruncatedJSONParse(response)
	}

	if jsonStr == "" {
		return nil, fmt.Errorf("no valid JSON found in AI response")
	}

	// Clean up common AI JSON issues
	jsonStr = e.agent.cleanJSONComments(jsonStr)

	var analysis AIPlanRecoveryAnalysis
	if err := json.Unmarshal([]byte(jsonStr), &analysis); err != nil {
		return nil, fmt.Errorf("failed to parse JSON response: %w", err)
	}

	// Validate the parsed analysis
	if analysis.Strategy == nil {
		return nil, fmt.Errorf("no recovery strategy provided by AI")
	}

	return &analysis, nil
}

// createFallbackAnalysis creates a basic analysis when AI parsing fails
func (e *DefaultPlanRecoveryEngine) createFallbackAnalysis(failureContext *PlanFailureContext) *AIPlanRecoveryAnalysis {
	e.agent.Logger.Warn("Creating fallback recovery strategy (AI analysis failed)")

	// Build a simple execution plan that retries from the failed step
	executionPlan := e.buildFallbackPlan(failureContext)

	// Create a simple retry strategy using standard ExecutionPlanStep format
	retryStrategy := &PlanRecoveryStrategy{
		Action:             "create_infrastructure",
		Reasoning:          "Fallback strategy: Retry may succeed if failure was transient. This plan retries the failed step with the same parameters.",
		Confidence:         0.5,
		SuccessProbability: 0.5,
		RiskLevel:          "medium",
		EstimatedDuration:  "5m",
		ExecutionPlan:      executionPlan,
		TotalSteps:         len(executionPlan), // Total includes completed + retry + remaining
		PreservedCount:     len(failureContext.CompletedSteps),
		NewStepsCount:      1, // Only the retry step is new
		RecoveryNotes:      "This is a fallback recovery strategy created because AI analysis was unavailable. It simply retries the failed step.",
	}

	return &AIPlanRecoveryAnalysis{
		FailureReason:     failureContext.FailureError,
		RootCause:         "Unable to determine root cause (AI analysis failed)",
		ImpactAssessment:  "Failure prevents completion of remaining steps",
		Confidence:        0.5,
		Strategy:          retryStrategy,
		RiskFactors:       []string{"AI analysis unavailable", "May fail again if issue is not transient"},
		SuccessFactors:    []string{"Transient failures sometimes resolve on retry"},
		AnalysisTimestamp: time.Now(),
	}
}

// buildFallbackPlan builds a simple fallback recovery plan using standard ExecutionPlanStep format
func (e *DefaultPlanRecoveryEngine) buildFallbackPlan(failureContext *PlanFailureContext) []*types.ExecutionPlanStep {
	var steps []*types.ExecutionPlanStep

	// FIRST: Include all completed steps with status="completed"
	for i := range failureContext.CompletedSteps {
		if i < len(failureContext.OriginalPlan) {
			originalStep := failureContext.OriginalPlan[i]
			completedStep := &types.ExecutionPlanStep{
				ID:                originalStep.ID,
				Name:              originalStep.Name,
				Description:       originalStep.Description,
				Action:            originalStep.Action,
				ResourceID:        originalStep.ResourceID,
				MCPTool:           originalStep.MCPTool,
				ToolParameters:    originalStep.ToolParameters,
				DependsOn:         originalStep.DependsOn,
				EstimatedDuration: originalStep.EstimatedDuration,
				Status:            "completed", // Mark as completed!
			}
			steps = append(steps, completedStep)
		}
	}

	// THEN: Retry the failed step
	retryStep := &types.ExecutionPlanStep{
		ID:                failureContext.FailedStepID + "-retry",
		Name:              failureContext.FailedStep.Name + " (Retry)",
		Description:       "Retry failed step with same parameters",
		Action:            failureContext.FailedStep.Action,
		ResourceID:        failureContext.FailedStep.ResourceID,
		MCPTool:           failureContext.FailedStep.MCPTool,
		ToolParameters:    failureContext.FailedStep.ToolParameters,
		DependsOn:         failureContext.FailedStep.DependsOn,
		EstimatedDuration: failureContext.FailedStep.EstimatedDuration,
		Status:            "pending",
	}
	steps = append(steps, retryStep)

	// Add remaining steps from original plan
	for _, remaining := range failureContext.RemainingSteps {
		step := &types.ExecutionPlanStep{
			ID:                remaining.ID,
			Name:              remaining.Name,
			Description:       remaining.Description,
			Action:            remaining.Action,
			ResourceID:        remaining.ResourceID,
			MCPTool:           remaining.MCPTool,
			ToolParameters:    remaining.ToolParameters,
			DependsOn:         remaining.DependsOn,
			EstimatedDuration: remaining.EstimatedDuration,
			Status:            "pending",
		}
		steps = append(steps, step)
	}

	return steps
}
