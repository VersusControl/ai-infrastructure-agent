package agent

import (
	"context"
	"fmt"
	"strings"
	"time"

	"github.com/tmc/langchaingo/llms"
)

// ========== Plan-Level Recovery Engine Implementation ==========

// DefaultPlanRecoveryEngine implements the PlanRecoveryEngine interface
type DefaultPlanRecoveryEngine struct {
	agent *StateAwareAgent
}

// NewPlanRecoveryEngine creates a new plan-level recovery engine
func NewPlanRecoveryEngine(agent *StateAwareAgent) PlanRecoveryEngine {
	return &DefaultPlanRecoveryEngine{
		agent: agent,
	}
}

// AnalyzePlanFailure analyzes a plan execution failure and generates recovery strategies
func (e *DefaultPlanRecoveryEngine) AnalyzePlanFailure(
	ctx context.Context,
	failureContext *PlanFailureContext,
) (*AIPlanRecoveryAnalysis, error) {
	startTime := time.Now()

	// Build comprehensive AI prompt for plan-level recovery
	prompt := e.GenerateRecoveryPrompt(failureContext)

	// Call AI model for analysis
	messages := []llms.MessageContent{
		{
			Role: llms.ChatMessageTypeSystem,
			Parts: []llms.ContentPart{
				llms.TextContent{Text: "You are an expert infrastructure recovery architect. When execution plans fail, you analyze the complete context and generate multiple recovery strategies that preserve completed work while fixing the failure. You provide 2-3 concrete recovery options with success probabilities, risk assessments, and complete new execution plans."},
			},
		},
		{
			Role: llms.ChatMessageTypeHuman,
			Parts: []llms.ContentPart{
				llms.TextContent{Text: prompt},
			},
		},
	}

	resp, err := e.agent.llm.GenerateContent(ctx, messages,
		llms.WithTemperature(0.1), // Low temperature for consistent, reliable analysis
		llms.WithMaxTokens(e.agent.config.MaxTokens))
	if err != nil {
		return nil, fmt.Errorf("AI consultation failed: %w", err)
	}

	// Extract response content
	var content string
	if len(resp.Choices) > 0 && len(resp.Choices[0].Content) > 0 {
		content = resp.Choices[0].Content
	} else {
		return nil, fmt.Errorf("empty response from AI model")
	}

	// Parse the AI response into structured analysis
	analysis, err := e.parsePlanRecoveryAnalysis(content, failureContext)
	if err != nil {
		e.agent.Logger.WithError(err).Error("Failed to parse AI plan recovery analysis")
		return nil, fmt.Errorf("failed to parse AI recovery analysis: %w", err)
	}

	// Add metadata
	analysis.AnalysisTimestamp = startTime
	analysis.AnalysisDuration = time.Since(startTime)

	// Validate strategy
	if analysis.Strategy != nil {
		if err := e.ValidateRecoveryStrategy(ctx, analysis.Strategy, failureContext); err != nil {
			e.agent.Logger.WithError(err).Error("Strategy validation failed")
			return nil, fmt.Errorf("recovery strategy validation failed: %w", err)
		}
	} else {
		e.agent.Logger.Error("No strategy generated by AI")
		return nil, fmt.Errorf("no recovery strategy generated by AI")
	}

	e.agent.Logger.WithFields(map[string]interface{}{
		"total_steps":          analysis.Strategy.TotalSteps,
		"preserved_count":      analysis.Strategy.PreservedCount,
		"new_steps_count":      analysis.Strategy.NewStepsCount,
		"success_probability":  analysis.Strategy.SuccessProbability,
		"risk_level":           analysis.Strategy.RiskLevel,
		"confidence":           analysis.Confidence,
		"analysis_duration_ms": analysis.AnalysisDuration.Milliseconds(),
	}).Info("Plan failure analysis completed successfully")

	return analysis, nil
}

// GenerateRecoveryPrompt creates the comprehensive prompt for AI consultation
func (e *DefaultPlanRecoveryEngine) GenerateRecoveryPrompt(failureContext *PlanFailureContext) string {
	// Build placeholders map
	placeholders := make(map[string]string)

	// Execution Overview
	placeholders["executionId"] = failureContext.ExecutionID
	placeholders["executionStarted"] = failureContext.ExecutionStarted.Format(time.RFC3339)
	placeholders["originalUserIntent"] = failureContext.OriginalUserIntent
	placeholders["originalAction"] = failureContext.OriginalAction
	placeholders["totalStepsInOriginalPlan"] = fmt.Sprintf("%d", len(failureContext.OriginalPlan))
	placeholders["attemptNumber"] = fmt.Sprintf("%d", failureContext.AttemptNumber)

	// Failure Information
	placeholders["failedStepNumber"] = fmt.Sprintf("%d", failureContext.FailedStepIndex+1)
	placeholders["totalSteps"] = fmt.Sprintf("%d", len(failureContext.OriginalPlan))
	placeholders["failedStepId"] = failureContext.FailedStepID
	placeholders["failedStepName"] = failureContext.FailedStep.Name
	placeholders["failedStepDescription"] = failureContext.FailedStep.Description
	placeholders["failedStepAction"] = failureContext.FailedStep.Action
	placeholders["failedStepMcpTool"] = failureContext.FailedStep.MCPTool
	placeholders["failureError"] = failureContext.FailureError
	placeholders["failureTime"] = failureContext.FailureTime.Format(time.RFC3339)

	// Failed Step Parameters
	var failedParamsBuilder strings.Builder
	if len(failureContext.FailedStep.ToolParameters) > 0 {
		failedParamsBuilder.WriteString("\n**Failed Step Parameters**:\n")
		for key, value := range failureContext.FailedStep.ToolParameters {
			failedParamsBuilder.WriteString(fmt.Sprintf("- `%s`: %v\n", key, value))
		}
	}
	placeholders["failedStepParameters"] = failedParamsBuilder.String()

	// Completed Steps
	placeholders["completedStepsCount"] = fmt.Sprintf("%d", len(failureContext.CompletedSteps))

	var completedStepsBuilder strings.Builder
	if len(failureContext.CompletedSteps) > 0 {
		for _, completedStep := range failureContext.CompletedSteps {
			completedStepsBuilder.WriteString(fmt.Sprintf("\n### Step %d: %s\n", completedStep.StepIndex+1, completedStep.StepName))
			completedStepsBuilder.WriteString(fmt.Sprintf("- **Step ID**: %s\n", completedStep.StepID))
			if completedStep.ResourceID != "" {
				completedStepsBuilder.WriteString(fmt.Sprintf("- **Resource Created**: %s (%s)\n", completedStep.ResourceID, completedStep.ResourceType))
			}
			completedStepsBuilder.WriteString(fmt.Sprintf("- **Status**: %s ✅\n", completedStep.Status))
			completedStepsBuilder.WriteString(fmt.Sprintf("- **Completed At**: %s\n", completedStep.CompletedAt.Format(time.RFC3339)))

			if len(completedStep.Output) > 0 {
				completedStepsBuilder.WriteString("- **Output Data**:\n")
				for key, value := range completedStep.Output {
					completedStepsBuilder.WriteString(fmt.Sprintf("  - `%s`: %v\n", key, value))
				}
			}
		}
	} else {
		completedStepsBuilder.WriteString("\nNo steps completed yet - failure occurred on first step.\n")
	}
	placeholders["completedStepsDetails"] = completedStepsBuilder.String()

	// Remaining Steps
	placeholders["remainingStepsCount"] = fmt.Sprintf("%d", len(failureContext.RemainingSteps))

	var remainingStepsBuilder strings.Builder
	if len(failureContext.RemainingSteps) > 0 {
		for i, remainingStep := range failureContext.RemainingSteps {
			remainingStepsBuilder.WriteString(fmt.Sprintf("\n### Remaining Step %d: %s\n", i+1, remainingStep.Name))
			remainingStepsBuilder.WriteString(fmt.Sprintf("- **Step ID**: %s\n", remainingStep.ID))
			remainingStepsBuilder.WriteString(fmt.Sprintf("- **Action**: %s\n", remainingStep.Action))
			remainingStepsBuilder.WriteString(fmt.Sprintf("- **MCP Tool**: %s\n", remainingStep.MCPTool))
			if len(remainingStep.DependsOn) > 0 {
				remainingStepsBuilder.WriteString(fmt.Sprintf("- **Depends On**: %v\n", remainingStep.DependsOn))
			}
		}
	}
	placeholders["remainingStepsDetails"] = remainingStepsBuilder.String()

	// Current Infrastructure State
	var stateBuilder strings.Builder
	if failureContext.CurrentState != nil && len(failureContext.CurrentState.Resources) > 0 {
		stateBuilder.WriteString("\n## Current Infrastructure State\n\n")
		stateBuilder.WriteString(fmt.Sprintf("**%d resources currently exist in infrastructure:**\n\n", len(failureContext.CurrentState.Resources)))
		for resourceID, resource := range failureContext.CurrentState.Resources {
			stateBuilder.WriteString(fmt.Sprintf("- **%s** (%s): %s\n", resourceID, resource.Type, resource.Status))
		}
	}
	placeholders["currentInfrastructureState"] = stateBuilder.String()

	// Resource Mappings
	var mappingsBuilder strings.Builder
	if len(failureContext.ResourceMappings) > 0 {
		mappingsBuilder.WriteString("\n## Resource Mappings (Step → Resource)\n\n")
		for stepID, resourceID := range failureContext.ResourceMappings {
			mappingsBuilder.WriteString(fmt.Sprintf("- Step `%s` → Resource `%s`\n", stepID, resourceID))
		}
	}
	placeholders["resourceMappings"] = mappingsBuilder.String()

	// Previous Recovery Attempts
	var attemptsBuilder strings.Builder
	if len(failureContext.PreviousRecoveryAttempts) > 0 {
		attemptsBuilder.WriteString("\n## Previous Recovery Attempts\n\n")
		attemptsBuilder.WriteString(fmt.Sprintf("**This is recovery attempt #%d. Previous attempts:**\n\n", failureContext.AttemptNumber))
		for _, attempt := range failureContext.PreviousRecoveryAttempts {
			attemptsBuilder.WriteString(fmt.Sprintf("### Attempt %d\n", attempt.AttemptNumber))
			attemptsBuilder.WriteString(fmt.Sprintf("- **Strategy Used**: %s\n", attempt.SelectedStrategy))
			attemptsBuilder.WriteString(fmt.Sprintf("- **Failed Because**: %s\n", attempt.FailureReason))
			if attempt.FailedAtStepID != "" {
				attemptsBuilder.WriteString(fmt.Sprintf("- **Failed At Step**: %s\n", attempt.FailedAtStepID))
			}
			attemptsBuilder.WriteString(fmt.Sprintf("- **Duration**: %s\n\n", attempt.Duration))
		}
	}
	placeholders["previousRecoveryAttempts"] = attemptsBuilder.String()

	// Available Tools - Use existing generateMCPToolsSchema for consistency
	// Get tool count from agent's MCP tools
	e.agent.capabilityMutex.RLock()
	toolsCount := len(e.agent.mcpTools)
	e.agent.capabilityMutex.RUnlock()

	placeholders["availableToolsCount"] = fmt.Sprintf("%d", toolsCount)

	// Generate MCP tools schema using the same method as other prompts
	toolsSchema := e.agent.generateMCPToolsSchema()
	placeholders["availableToolsDetails"] = toolsSchema

	// Load and process template
	prompt, err := e.agent.loadTemplateWithPlaceholders("settings/templates/recovery-prompt-optimized.txt", placeholders)
	if err != nil {
		e.agent.Logger.WithError(err).Error("Failed to load recovery prompt template, using fallback")
		// Return minimal fallback prompt
		return fmt.Sprintf(`Analyze this plan failure and generate a recovery strategy in JSON format:

Execution: %s
Failed Step: %s (step %d/%d)
Error: %s

Completed Steps (%d):
%s

Generate ONE recovery strategy with standard ExecutionPlanStep format. Return only valid JSON.`,
			failureContext.ExecutionID,
			failureContext.FailedStepID,
			failureContext.FailedStepIndex+1,
			len(failureContext.OriginalPlan),
			failureContext.FailureError,
			len(failureContext.CompletedSteps),
			func() string {
				var b strings.Builder
				for _, s := range failureContext.CompletedSteps {
					b.WriteString(fmt.Sprintf("- %s: %s\n", s.StepID, s.ResourceID))
				}
				return b.String()
			}())
	}

	return prompt
}

// ValidateRecoveryStrategy ensures the proposed recovery strategy is safe and feasible
func (e *DefaultPlanRecoveryEngine) ValidateRecoveryStrategy(
	ctx context.Context,
	strategy *PlanRecoveryStrategy,
	failureContext *PlanFailureContext,
) error {

	// Validate action (same as AgentDecision)
	validActions := map[string]bool{
		"create_infrastructure": true,
		"update_infrastructure": true,
		"delete_infrastructure": true,
	}
	if !validActions[strategy.Action] {
		return fmt.Errorf("invalid action: %s", strategy.Action)
	}

	// Validate confidence
	if strategy.Confidence < 0.0 || strategy.Confidence > 1.0 {
		return fmt.Errorf("invalid confidence: %f (must be 0.0-1.0)", strategy.Confidence)
	}

	// Validate success probability
	if strategy.SuccessProbability < 0.0 || strategy.SuccessProbability > 1.0 {
		return fmt.Errorf("invalid success probability: %f (must be 0.0-1.0)", strategy.SuccessProbability)
	}

	// Validate risk level
	validRiskLevels := map[string]bool{"low": true, "medium": true, "high": true}
	if !validRiskLevels[strategy.RiskLevel] {
		return fmt.Errorf("invalid risk level: %s (must be low/medium/high)", strategy.RiskLevel)
	}

	// Validate execution plan
	if len(strategy.ExecutionPlan) == 0 {
		return fmt.Errorf("execution plan must have at least one step")
	}

	// Validate step counts match the actual execution plan length
	// TotalSteps should equal the length of executionPlan (completed + new + remaining)
	if strategy.TotalSteps != len(strategy.ExecutionPlan) {
		return fmt.Errorf("total steps (%d) doesn't match execution plan length (%d)",
			strategy.TotalSteps, len(strategy.ExecutionPlan))
	}

	// Validate that preserved count doesn't exceed total
	if strategy.PreservedCount > strategy.TotalSteps {
		return fmt.Errorf("preserved count (%d) cannot exceed total steps (%d)",
			strategy.PreservedCount, strategy.TotalSteps)
	}

	// Validate tools exist
	e.agent.capabilityMutex.RLock()
	defer e.agent.capabilityMutex.RUnlock()

	// Valid recovery actions
	validRecoveryActions := map[string]bool{
		"create": true,
		"query":  true,
		"modify": true,
	}

	for _, step := range strategy.ExecutionPlan {
		// Validate step action
		if !validRecoveryActions[step.Action] {
			return fmt.Errorf("invalid step action: %s (must be create, query, or modify)", step.Action)
		}

		if step.MCPTool == "" {
			return fmt.Errorf("step %s missing mcpTool", step.ID)
		}
		// Check tool exists
		if _, exists := e.agent.mcpTools[step.MCPTool]; !exists {
			return fmt.Errorf("tool %s not available", step.MCPTool)
		}
	}

	return nil
}
